"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol?"symbol":typeof n};!function(n){"function"==typeof require&&"object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"object"===("undefined"==typeof module?"undefined":_typeof(module))?n(require("knockout")):"function"==typeof define&&define.amd?define(["knockout"],n):n(window.ko)}(function(n){function e(e,o,t){if("component"in o()){var i=e.children[0];return i?n.contextFor(i).$component:t.$component}return t.$component}n.bindingHandlers.ref={refs:{},update:function(o,t,i,r,f){"component"in i()||console.warn&&console.warn("ref binding should be used together with a component binding, otherwise you might leak memory if the component binding can change dynamically.");var c=n.bindingHandlers.ref.refs,d=n.unwrap(t());n.tasks.schedule(function(){var t=e(o,i,f);c[d]=c[d]?c[d](t):n.observable(t),n.utils.domNodeDisposal.addDisposeCallback(o,function(){return delete c[d]})})},after:["component"]},n.bindingHandlers.refFn={init:function(e,o,t,i,r){var f=n.unwrap(o()),c=f.callback,d=f.ref;return n.applyBindingsToDescendants(r,e),n.tasks.schedule(function(){c(n.bindingHandlers.ref.refs[d])}),{controlsDescendantBindings:!0}},after:["ref"]}});