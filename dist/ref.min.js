"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol?"symbol":typeof n};!function(n){"function"==typeof require&&"object"===("undefined"==typeof exports?"undefined":_typeof(exports))&&"object"===("undefined"==typeof module?"undefined":_typeof(module))?module.exports=n(require("knockout")):"function"==typeof define&&define.amd?define(["knockout"],n):n(window.ko)}(function(n){function e(e,o,t){if("component"in o()){var r=e.children[0];return r?n.contextFor(r).$component:t.$component}return t.$component}return n.bindingHandlers.ref={refs:{},update:function(o,t,r,i,f){"component"in r()||console.warn&&console.warn("ref binding should be used together with a component binding, otherwise you might leak memory if the component binding can change dynamically.");var d=n.bindingHandlers.ref.refs,c=n.unwrap(t());n.tasks.schedule(function(){var t=e(o,r,f);d[c]=d.hasOwnProperty(c)?d[c](t):n.observable(t),n.utils.domNodeDisposal.addDisposeCallback(o,function(){return delete d[c]})})},after:["component"]},n.bindingHandlers.refFn={init:function(e,o,t,r,i){var f=n.unwrap(o()),d=f.callback,c=f.ref;return n.applyBindingsToDescendants(i,e),n.tasks.schedule(function(){d(n.bindingHandlers.ref.refs[c])}),{controlsDescendantBindings:!0}},after:["ref"]},n.bindingHandlers.ref.refs});